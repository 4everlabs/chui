OpenTUI + Convex (Bun) - MVP #0: Design-system-first login flow (Jan 2026)
=========================================================================

Goal
----
Build a design-system-first TUI with a simple splash + login flow.
All UI styling must come from a shared design system and reusable components.

Behavior:
- Splash screen shows "CHUI", tagline, and a square "enter" button.
- Clicking "enter" swaps to the login screen.
- Login screen shows:
  - subheading label "username"
  - input field
  - login button (text color #444444)
- When login is wired to Convex:
  - If the username already exists -> treat as "logged in".
  - If it does not exist -> create the user and then treat as "logged in".
  - No passwords, no sessions, no auth providers. This is purely to unblock TUI iteration.

Technical spec (MVP #0, Jan 2026 best practices)
------------------------------------------------
1) Data model (Convex)
   Table: users
   - username: string (unique, normalized)
   - _creationTime: number (ms epoch, system field added by Convex)
     Optional: createdAt: number (ms epoch) only if you need custom timestamps.

   Index:
   - by_username (username)

2) Backend API surface
   Mutation: users.upsertByUsername({ username: string }) -> { userId, username }
     - normalize username (trim + lowercase)
     - validate: 3..20 chars, [a-z0-9_]
     - use argument validators (v.string())
     - query with .withIndex("by_username").unique()
     - if exists return existing
     - else insert and return
     - await all async calls (Convex best practice)

3) TUI behavior (OpenTUI core, imperative, design-system-first)
   Screens:
   - Splash (CHUI + tagline + square enter button)
   - Login (subheading label + input + login button)

   Components:
   - Centralized design system (colors, spacing, sizes, text styles)
   - Reusable button component that reads design tokens
   - Screen factory functions that compose renderables

   Events:
   - Splash enter button: swap to login screen
   - Input ENTER: call Convex mutation users.upsertByUsername
   - On success: update status line or swap screen to a "LoggedIn placeholder"

4) Runtime
   - Bun executes the TUI process.
   - Convex dev server runs in a separate terminal and generates convex/_generated.
   - TUI uses ConvexHttpClient (one-shot mutation) from convex/browser.

Convex best-practice notes (Jan 2026)
-------------------------------------
- Await all promises in Convex functions (avoid floating promises).
- Prefer .withIndex/.withSearchIndex over .filter; keep .collect for small results.
- Avoid redundant indexes; for this MVP only by_username is needed.
- Use argument validators on all public functions.

References used (checked Jan 2026)
----------------------------------
- Convex Bun client docs: https://docs.convex.dev/client/javascript/bun
- Convex Bun quickstart: https://docs.convex.dev/quickstart/bun
- ConvexHttpClient API: https://docs.convex.dev/api/classes/browser.ConvexHttpClient
- Convex best practices: https://docs.convex.dev/production/best-practices
- Convex schemas: https://docs.convex.dev/database/schemas
- Convex indexes: https://docs.convex.dev/database/reading-data/indexes
- OpenTUI getting started: https://opentui.com/docs/getting-started
- OpenTUI Input docs: https://opentui.com/docs/components/input

================================================================================
PART A - Create the Bun project + install deps
================================================================================

0) Prereqs
- Bun installed: https://bun.sh
- A terminal that supports ANSI well (iTerm2 / Terminal.app / Kitty / etc.)
- Convex CLI runs via bunx (recommended).
- Zig is only required if you build OpenTUI native code.

1) Create project folder
Option A (recommended): create-tui (core template)
  bunx create-tui@latest -t core tui-chat
  cd tui-chat

  Note: options must come before the app name (per create-tui rules).

Option B (manual)
  mkdir tui-chat
  cd tui-chat
  bun init -y

2) Install packages (latest)
  bun add convex @opentui/core

3) Create TypeScript config (tsconfig.json)
  Use ESM modules.

  tsconfig.json:
  {
    "compilerOptions": {
      "target": "ES2022",
      "module": "ES2022",
      "moduleResolution": "Bundler",
      "strict": true,
      "esModuleInterop": true,
      "skipLibCheck": true,
      "types": ["bun-types"]
    }
  }

4) Add run scripts to package.json (recommended)
  package.json:
  {
    ...
    "type": "module",
    "scripts": {
      "dev": "bun run --watch src/index.ts",
      "start": "bun run src/index.ts"
    }
  }

================================================================================
PART B - Convex backend (bare minimum, step-by-step)
================================================================================

1) Start the Convex dev server (keep it running)
  bunx convex dev

  What happens:
  - you authenticate in the browser
  - a dev deployment is created
  - convex/ directory is created (if missing)
  - .env.local is created with CONVEX_DEPLOYMENT and URLs

2) Confirm files exist
  convex/
    _generated/
    ...
  .env.local

3) Create the minimal schema (users table + index)
  convex/schema.ts
  ----------------------------------------------------------------
  import { defineSchema, defineTable } from "convex/server";
  import { v } from "convex/values";

  export default defineSchema({
    users: defineTable({
      username: v.string(),
      // createdAt: v.number(), // optional; prefer _creationTime if you don't need custom
    }).index("by_username", ["username"]),
  });
  ----------------------------------------------------------------

4) Create the minimal mutation (upsert by username)
  convex/users.ts
  ----------------------------------------------------------------
  import { mutation } from "convex/server";
  import { v } from "convex/values";

  const USERNAME_RE = /^[a-z0-9_]{3,20}$/;

  function normalizeUsername(raw: string): string {
    return raw.trim().toLowerCase();
  }

  export const upsertByUsername = mutation({
    args: { username: v.string() },
    handler: async (ctx, args) => {
      const username = normalizeUsername(args.username);

      if (!USERNAME_RE.test(username)) {
        throw new Error("Username must be 3-20 characters: [a-z0-9_]");
      }

      const existing = await ctx.db
        .query("users")
        .withIndex("by_username", (q) => q.eq("username", username))
        .unique();

      if (existing) {
        return { userId: existing._id, username: existing.username };
      }

      const userId = await ctx.db.insert("users", {
        username,
        // createdAt: Date.now(), // only if you kept createdAt in the schema
      });

      return { userId, username };
    },
  });
  ----------------------------------------------------------------

5) Wait for typegen to update
- Keep bunx convex dev running; it regenerates:
  convex/_generated/api.d.ts
  convex/_generated/api.js
  convex/_generated/dataModel.d.ts
- You should see users.upsertByUsername in the generated api object.

Bare minimum backend checklist
------------------------------
- convex dev server running
- users table + by_username index in schema
- users.upsertByUsername mutation
- api generated (users.upsertByUsername shows up)

================================================================================
PART C - Build splash + login screens (design system first)
================================================================================

We will:
- Create a design system module and reusable UI components
- Build splash + login screens using those shared styles
- Wire screens in src/index.ts and swap on "enter"

1) Create the design system first (single source of truth)

  src/ui/design_system.ts
  ----------------------------------------------------------------
  - colors: red, teal, yellow, white, and gray scale
  - spacing: xs, sm
  - sizes: inputWidth, buttonSquare, buttonWide, buttonHeight
  - textStyles: heading, subheading, body, muted
  - helpers: createHeadingText, createSubheadingText, createBodyText
  - buttonStyles: primary/accent/danger/muted
  ----------------------------------------------------------------

  Rule: no ad-hoc styling outside the design system.

2) Create reusable UI components

  src/ui/components/button.ts
  ----------------------------------------------------------------
  createButton(renderer, { label, width, height, variant, onPress })
  - uses BoxRenderable + TextRenderable
  - reads colors from buttonStyles in the design system
  - onMouseUp triggers onPress
  ----------------------------------------------------------------

3) Create screens that consume the design system

  src/ui/screens/splash.ts
  ----------------------------------------------------------------
  - ASCIIFont "CHUI" (teal)
  - body text tagline (body style)
  - square "enter" button (accent/yellow)
  - accepts onEnter callback
  ----------------------------------------------------------------

  src/ui/screens/login.ts
  ----------------------------------------------------------------
  - subheading label "username"
  - input width = sizes.inputWidth
  - login button (muted), text color #444444
  - exports { view, input } for wiring
  ----------------------------------------------------------------

4) Wire it in src/index.ts (imperative root setup)

  - create renderer
  - create login screen + splash screen
  - add splash to root
  - onEnter: remove splash, add login, focus input
  - include .ts extensions in local imports

5) Later (when wiring Convex):
  - handle InputRenderableEvents.ENTER on the login input
  - call users.upsertByUsername via ConvexHttpClient
  - show status using design-system text styles

6) Create .env with your Convex deployment URL
Convex creates .env.local for its own tooling, but your Bun app needs a URL.
Set this in a project .env:

  .env
  CONVEX_URL=https://<your-deployment>.convex.cloud

How to get it:
- Copy the deployment URL from the Convex dashboard, or
- Read it from the "convex dev" startup output (it prints the URL).

================================================================================
PART D - Run the TUI
================================================================================

Terminal A:
  bunx convex dev
(keep running)

Terminal B:
  bun run src/index.ts
  # or: bun run dev

You should see:
- Title "TUI Chat - Login"
- Input focused
- After typing a username and pressing Enter:
  - first time: creates user
  - second time: returns existing user

================================================================================
PART E - What this unlocks next (not doing it yet)
================================================================================

Once this screen renders and the mutation works, the next minimal steps are:
1) Inbox screen:
   - list all users (users.listAll query)
   - select one user to open a DM
2) DM creation:
   - dms.getOrCreate(userIdA, userIdB)
3) Chat screen:
   - subscribe to messages for dmId using ConvexClient (WebSocket)
   - send messages via mutation

But do not add these until your login screen feels good visually.

================================================================================
Troubleshooting / bug scan checklist
================================================================================

1) "Missing CONVEX_URL"
- Create .env and set CONVEX_URL to your convex.cloud deployment URL.

2) Convex typegen missing api.users.upsertByUsername
- Ensure bunx convex dev is running.
- Ensure convex/users.ts exports upsertByUsername.
- Restart convex dev after schema changes if necessary.

3) Input does not submit on Enter
- Use InputRenderableEvents.ENTER (not a custom "submit" event).
- Ensure input.focus() is called.

4) ESM import errors
- Ensure package.json has "type": "module".
- Import generated api with .js extension as shown.

5) Terminal left in a weird state
- Avoid process.exit(); use renderer.destroy() or exitOnCtrlC: true.

================================================================================
End
================================================================================
